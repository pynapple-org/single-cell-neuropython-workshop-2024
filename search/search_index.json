{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Single Cell Neuropython Workshop 2024","text":"<p>Welcome to the Pynapple and NeMoS material for the Single Cell Neuropython 2024.</p> <p>Here you will find:</p> <ul> <li>Workshop's tutorial: The tutorial that will be used during the workshop</li> <li>Solutions: A fully worked out version of the tutorial.</li> <li>Load Allen Brain Map to Pynapple: An example of how to load an intracellular recording NWB to pynapple.</li> </ul>"},{"location":"generated/gallery/","title":"Index","text":"<p>hide:  - toc</p>"},{"location":"generated/gallery/#single-cell-neuropython-workshop-2024","title":"Single Cell Neuropython Workshop 2024","text":"<p>Welcome to the Pynapple and NeMoS material for workshop.</p> <p> Load an Allen Brain Map NWB into pynapple </p> <p> Tutorial pynapple &amp; NeMoS </p> <p> Solutions tutorial pynapple &amp; NeMoS </p> <p> Download all examples in Python source code: gallery_python.zip</p> <p> Download all examples in Jupyter notebooks: gallery_jupyter.zip</p> <p>Gallery generated by mkdocs-gallery</p>"},{"location":"generated/gallery/example_load_to_pynapple/","title":"Example load to pynapple","text":"<p>Note</p> <p>Click here to download the full example code</p>"},{"location":"generated/gallery/example_load_to_pynapple/#load-an-allen-brain-map-nwb-into-pynapple","title":"Load an Allen Brain Map NWB into pynapple","text":"<p>In this example, we show how to load into pynapple an NWB directly downloaded from the Allen Brain Map.</p> <p>Intracellular recordings NWBs and pynapple</p> <p>NWB files containing intracellular recordings cannot be imported directly into pynapple. This is because pynapple requires a continuous time axis, but these experiments are typically divided into sweeps, with each sweep starting at t = 0 seconds.</p> <p>At this link, we provide the <code>load_allen.py</code> module for loading intracellular recordings into <code>pynapple</code>.  It works by concatenating all sweeps together and adding a fixed inter-trial interval between sweeps to  create a continuous time axis.</p> <p>For this example, let's assume that you download the dataset used in the tutorial directly from the Allen website:</p> <p>https://celltypes.brain-map.org/experiment/electrophysiology/478498617</p> <p>To load it into pynapple, you can run the following code,</p> <pre><code># The \"load_allen.py\" module is in\n# https://github.com/pynapple-org/single-cell-neuropython-workshop-2024/blob/main/docs/examples/load_allen.py\nfrom load_allen import load_to_pynapple\n\n# replace this with the path to the nwb data\npath = \"478498615_ephys.nwb\"\n\n# this will return the pynapple representation of the data.\n# note: that we used the same naming as in \"tutorial_pynapple_nemos_single_cell_full.py\"\nspikes, epochs,  current, voltage, sweep_metadata = load_to_pynapple(path)\n</code></pre> <p>Total running time of the script: ( 0 minutes  0.000 seconds)</p> <p> Download Python source code: example_load_to_pynapple.py</p> <p> Download Jupyter notebook: example_load_to_pynapple.ipynb</p> <p>Gallery generated by mkdocs-gallery</p>"},{"location":"generated/gallery/mg_execution_times/","title":"Computation times","text":"<p>00:14.695 total execution time for generated_gallery files:</p> <p>+-------------------------------------------------------------------------------------------------------------------------------------------------------+-----------+--------+ | tutorial_pynapple_nemos_single_cell_full (docs/examples/tutorial_pynapple_nemos_single_cell_full.py) | 00:08.606 | 0.0 MB | +-------------------------------------------------------------------------------------------------------------------------------------------------------+-----------+--------+ | tutorial_pynapple_nemos_single_cell (docs/examples/tutorial_pynapple_nemos_single_cell.py)                | 00:06.089 | 0.0 MB | +-------------------------------------------------------------------------------------------------------------------------------------------------------+-----------+--------+ | example_load_to_pynapple (docs/examples/example_load_to_pynapple.py)                                                 | 00:00.000 | 0.0 MB | +-------------------------------------------------------------------------------------------------------------------------------------------------------+-----------+--------+</p>"},{"location":"generated/gallery/tutorial_pynapple_nemos_single_cell/","title":"Tutorial pynapple nemos single cell","text":"<p>Note</p> <p>Click here to download the full example code</p>"},{"location":"generated/gallery/tutorial_pynapple_nemos_single_cell/#tutorial-pynapple-nemos","title":"Tutorial pynapple &amp; NeMoS","text":"<p>Data for this notebook is a patch clamp experiment with a mouse V1 neuron, from the Allen Brain Atlas</p> <p></p>"},{"location":"generated/gallery/tutorial_pynapple_nemos_single_cell/#learning-objectives","title":"Learning objectives","text":"<ul> <li>Learn how to explore spiking data and do basic analyses using pynapple</li> <li>Learn how to structure data for NeMoS</li> <li>Learn how to fit a basic Generalized Linear Model using NeMoS</li> <li>Learn how to retrieve the parameters and predictions from a fit GLM for   intrepetation.</li> </ul> <p>Warning</p> <p>This tutorial uses matplotlib for displaying the figure</p> <p>You can install all with <code>pip install matplotlib requests tqdm</code></p> <pre><code># !pip install matplotlib requests tqdm\n</code></pre> <p>In case you did not install beforehand pynapple and nemos, here is the command to install it.</p> <pre><code># !pip install pynapple nemos\n</code></pre> <p>Import everything</p> <pre><code>import math\nimport os\n\nimport jax\nimport matplotlib.pyplot as plt\nimport nemos as nmo\nimport nemos.glm\nimport numpy as np\nimport pynapple as nap\nimport requests\nimport tqdm\nimport workshop_utils.plotting as plotting\n</code></pre> <p>configure plots some</p> <pre><code>plt.style.use(\"workshop_utils/nemos.mplstyle\")\n</code></pre>"},{"location":"generated/gallery/tutorial_pynapple_nemos_single_cell/#data-streaming","title":"Data Streaming","text":"<ul> <li>Stream the data. Format is Neurodata Without Borders (NWB) standard</li> </ul> <pre><code>path = \"allen_478498617.nwb\"\nif path not in os.listdir(\".\"):\n  r = requests.get(f\"https://osf.io/vf2nj/download\", stream=True)\n  block_size = 1024*1024\n  with open(path, 'wb') as f:\n    for data in tqdm.tqdm(r.iter_content(block_size), unit='MB', unit_scale=True,\n      total=math.ceil(int(r.headers.get('content-length', 0))//block_size)):\n      f.write(data)\n</code></pre>"},{"location":"generated/gallery/tutorial_pynapple_nemos_single_cell/#pynapple","title":"Pynapple","text":""},{"location":"generated/gallery/tutorial_pynapple_nemos_single_cell/#data-structures-and-preparation","title":"Data structures and preparation","text":"<ul> <li>Open the NWB file with pynapple</li> </ul> <ul> <li><code>stimulus</code>: Tsd containing injected current, in Amperes, sampled at 20k Hz.</li> <li><code>response</code>: Tsd containing the neuron's intracellular voltage, sampled at 20k Hz.</li> <li><code>units</code>: Tsgroup, dictionary of neurons, holding each neuron's spike timestamps.</li> <li><code>epochs</code>: IntervalSet, dictionary with start and end times of different intervals,   defining the experimental structure, specifying when each stimulation protocol began   and ended.</li> </ul> <ul> <li><code>Noise 1</code>: epochs of random noise</li> </ul> <ul> <li>Let's focus on the first epoch.</li> </ul> <ul> <li><code>current</code> : Tsd (TimeSeriesData) : time index + data</li> </ul> <pre><code># convert current from Ampere to pico-amperes, to match the Allen Institute figures and\n# move the values to a more reasonable range.\n</code></pre> <ul> <li><code>restrict</code> : restricts a time series object to a set of time intervals delimited by an IntervalSet object</li> </ul> <ul> <li><code>TsGroup</code> : a custom dictionary holding multiple <code>Ts</code> (timeseries) objects with   potentially different time indices.</li> </ul> <p>We can index into the <code>TsGroup</code> to see the timestamps for this neuron's spikes:</p> <p>Let's restrict to the same epoch <code>noise_interval</code>:</p> <p>Let's visualize the data from this trial:</p> <pre><code># fig, ax = plt.subplots(1, 1, figsize=(8, 2))\n# ax.plot(current, \"grey\")\n# ax.plot(spikes.to_tsd([-5]), \"|\", color=\"k\", ms = 10)\n# ax.set_ylabel(\"Current (pA)\")\n# ax.set_xlabel(\"Time (s)\")\n</code></pre>"},{"location":"generated/gallery/tutorial_pynapple_nemos_single_cell/#basic-analyses","title":"Basic analyses","text":"<p>The Generalized Linear Model gives a predicted firing rate. First we can use pynapple to visualize this firing rate for a single trial.</p> <ul> <li><code>count</code> : count the number of events within <code>bin_size</code></li> </ul> <p>Let's convert the spike counts to firing rate :</p> <ul> <li><code>smooth</code> : convolve with a Gaussian kernel</li> </ul> <p>the inputs to this function are the standard deviation of the gaussian in seconds and the full width of the window, in standard deviations. So std=.05 and size_factor=20 gives a total filter size of 0.05 sec * 20 = 1 sec.</p> <p>convert from spikes per bin to spikes per second (Hz)</p> <p>we're hiding the details of the plotting function for the purposes of this tutorial, but you can find it in the associated github repo if you're interested: https://github.com/flatironinstitute/ccn-workshop-fens-2024/blob/main/src/workshop_utils/plotting.py</p> <pre><code># plotting.current_injection_plot(current, spikes, firing_rate)\n</code></pre> <p>What is the relationship between the current and the spiking activity? <code>compute_1d_tuning_curves</code> : compute the firing rate as a function of a 1-dimensional feature.</p> <p>Let's plot the tuning curve of the neuron.</p> <pre><code># plotting.tuning_curve_plot(tuning_curve)\n</code></pre>"},{"location":"generated/gallery/tutorial_pynapple_nemos_single_cell/#nemos","title":"NeMoS","text":""},{"location":"generated/gallery/tutorial_pynapple_nemos_single_cell/#preparing-data","title":"Preparing data","text":"<p>Get data from pynapple to NeMoS-ready format:</p> <ul> <li>predictors and spikes must have same number of time points</li> </ul> <pre><code># enter code here\n</code></pre> <ul> <li>predictors must be 2d, spikes 1d</li> </ul> <pre><code># enter code here\n</code></pre>"},{"location":"generated/gallery/tutorial_pynapple_nemos_single_cell/#fitting-the-model","title":"Fitting the model","text":"<ul> <li>define a GLM object</li> </ul> <pre><code># enter code here\n</code></pre> <ul> <li>call fit and retrieve parameters</li> </ul> <pre><code># enter code here\n</code></pre> <ul> <li>generate and examine model predictions.</li> </ul> <pre><code># enter code here\n# plotting.current_injection_plot(current, spikes, firing_rate,\n#                                                smooth_predicted_fr)\n</code></pre> <ul> <li>what do we see?</li> </ul> <pre><code># enter code here\n</code></pre> <ul> <li>examine tuning curve \u2014 what do we see?</li> </ul> <pre><code># enter code here\n# fig = plotting.tuning_curve_plot(tuning_curve)\n# fig.axes[0].plot(tuning_curve_model, color=\"tomato\", label=\"glm\")\n# fig.axes[0].legend()\n</code></pre>"},{"location":"generated/gallery/tutorial_pynapple_nemos_single_cell/#extending-the-model","title":"Extending the model","text":"<ul> <li>choose a length of time over which the neuron integrates the input current</li> </ul> <pre><code># enter code here\n</code></pre> <ul> <li>define a basis object</li> </ul> <pre><code># enter code here\n</code></pre> <ul> <li>create the design matrix</li> <li>examine the features it contains</li> </ul> <pre><code># enter code here\n# in this plot, we're normalizing the amplitudes to make the comparison easier --\n# the amplitude of these features will be fit by the model, so their un-scaled\n# amplitudes is not informative\n# plotting.plot_current_history_features(binned_current, current_history, basis,\n#                                                       current_history_duration_sec)\n</code></pre> <ul> <li>create and fit the GLM</li> <li>examine the parameters</li> </ul> <pre><code># enter code here\n</code></pre> <ul> <li>compare the predicted firing rate to the data and the old model</li> <li>what do we see?</li> </ul> <pre><code># enter code here\n</code></pre> <ul> <li>examine the predicted average firing rate and tuning curve</li> <li>what do we see?</li> </ul> <pre><code># enter code here\n</code></pre> <ul> <li>use log-likelihood to compare models</li> </ul> <pre><code># enter code here\n</code></pre>"},{"location":"generated/gallery/tutorial_pynapple_nemos_single_cell/#finishing-up","title":"Finishing up","text":"<ul> <li>what if you want to compare models across datasets?</li> </ul> <pre><code># enter code here\n</code></pre> <ul> <li>what about spiking?</li> </ul> <pre><code># enter code here\n</code></pre>"},{"location":"generated/gallery/tutorial_pynapple_nemos_single_cell/#further-exercises","title":"Further Exercises","text":"<ul> <li>what else can we do?</li> </ul>"},{"location":"generated/gallery/tutorial_pynapple_nemos_single_cell/#data-citation","title":"Data citation","text":"<p>The data used in this tutorial is from the Allen Brain Map, with the following citation:</p> <p>Contributors: Agata Budzillo, Bosiljka Tasic, Brian R. Lee, Fahimeh Baftizadeh, Gabe Murphy, Hongkui Zeng, Jim Berg, Nathan Gouwens, Rachel Dalley, Staci A. Sorensen, Tim Jarsky, Uygar S\u00fcmb\u00fcl Zizhen Yao</p> <p>Dataset: Allen Institute for Brain Science (2020). Allen Cell Types Database -- Mouse Patch-seq [dataset]. Available from brain-map.org/explore/classes/multimodal-characterization.</p> <p>Primary publication: Gouwens, N.W., Sorensen, S.A., et al. (2020). Integrated morphoelectric and transcriptomic classification of cortical GABAergic cells. Cell, 183(4), 935-953.E19. https://doi.org/10.1016/j.cell.2020.09.057</p> <p>Patch-seq protocol: Lee, B. R., Budzillo, A., et al. (2021). Scaled, high fidelity electrophysiological, morphological, and transcriptomic cell characterization. eLife, 2021;10:e65482. https://doi.org/10.7554/eLife.65482</p> <p>Mouse VISp L2/3 glutamatergic neurons: Berg, J., Sorensen, S. A., Miller, J., Ting, J., et al. (2021) Human neocortical expansion involves glutamatergic neuron diversification. Nature, 598(7879):151-158. doi: 10.1038/s41586-021-03813-8</p> <p>Total running time of the script: ( 0 minutes  6.089 seconds)</p> <p> Download Python source code: tutorial_pynapple_nemos_single_cell.py</p> <p> Download Jupyter notebook: tutorial_pynapple_nemos_single_cell.ipynb</p> <p>Gallery generated by mkdocs-gallery</p>"},{"location":"generated/gallery/tutorial_pynapple_nemos_single_cell_full/","title":"Tutorial pynapple nemos single cell full","text":"<p>Note</p> <p>Click here to download the full example code</p>"},{"location":"generated/gallery/tutorial_pynapple_nemos_single_cell_full/#solutions-tutorial-pynapple-nemos","title":"Solutions tutorial pynapple &amp; NeMoS","text":"<p>For our first example, we will look at a very simple dataset: patch-clamp recordings from a single neuron in layer 4 of mouse primary visual cortex. This data is from the Allen Brain Atlas, and experimenters injected current directly into the cell, while recording the neuron's membrane potential and spiking behavior. The experiments varied the shape of the current across many sweeps, mapping the neuron's behavior in response to a wide range of potential inputs.</p> <p>For our purposes, we will examine only one of these sweeps, \"Noise 1\", in which the experimentalists injected three pulses of current. The current is a square pulse multiplied by a sinusoid of a fixed frequency, with some random noise riding on top.</p> <p></p> <p>In the figure above (from the Allen Brain Atlas website), we see the approximately 22 second sweep, with the input current plotted in the first row, the intracellular voltage in the second, and the recorded spikes in the third. (The grey lines and dots in the second and third rows comes from other sweeps with the same stimulus, which we'll ignore in this exercise.) When fitting the Generalized Linear Model, we are attempting to model the spiking behavior, and we generally do not have access to the intracellular voltage, so for the rest of this notebook, we'll use only the input current and the recorded spikes displayed in the first and third rows.</p> <p>First, let us see how to load in the data and reproduce the above figure, which we'll do using pynapple. This will largely be a review of what we went through yesterday. After we've explored the data some, we'll introduce the Generalized Linear Model and how to fit it with NeMoS.</p>  Data for this notebook is a patch clamp experiment with a mouse V1 neuron, from the [Allen Brain Atlas](https://celltypes.brain-map.org/experiment/electrophysiology/478498617)  ![Allen Brain Atlas view of the data we will analyze.](../../assets/allen_data.png)"},{"location":"generated/gallery/tutorial_pynapple_nemos_single_cell_full/#learning-objectives","title":"Learning objectives","text":"<ul> <li>Learn how to explore spiking data and do basic analyses using pynapple</li> <li>Learn how to structure data for NeMoS</li> <li>Learn how to fit a basic Generalized Linear Model using NeMoS</li> <li>Learn how to retrieve the parameters and predictions from a fit GLM for   intrepetation.</li> </ul> <p>Warning</p> <p>This tutorial uses matplotlib for displaying the figure</p> <p>You can install all with <code>pip install matplotlib requests tqdm</code></p> <pre><code># !pip install matplotlib requests tqdm\n</code></pre> <p>In case you did not install beforehand pynapple and nemos, here is the command to install it.</p> <pre><code># !pip install pynapple nemos\n\nimport math\nimport os\n</code></pre> <p>Import everything</p> <pre><code>import jax\nimport matplotlib.pyplot as plt\nimport nemos as nmo\nimport numpy as np\nimport pynapple as nap\nimport requests\nimport tqdm\nimport workshop_utils.plotting as plotting\n\n# configure plots some\nplt.style.use(\"workshop_utils/nemos.mplstyle\")\n</code></pre>"},{"location":"generated/gallery/tutorial_pynapple_nemos_single_cell_full/#data-streaming","title":"Data Streaming","text":"<p>While you can download the data directly from the Allen Brain Atlas and interact with it using their AllenSDK, we prefer the burgeoning Neurodata Without Borders (NWB) standard. We have converted this single dataset to NWB and uploaded it to the Open Science Framework. This allows us to easily load the data using pynapple, and it will immediately be in a format that pynapple understands!</p> <p>Tip</p> <p>Pynapple can stream any NWB-formatted dataset! See their documentation for more details, and see the DANDI Archive for a repository of compliant datasets.</p> <p>The first time the following cell is run, it will take a little bit of time to download the data, and a progress bar will show the download's progress. On subsequent runs, the cell gets skipped: we do not need to redownload the data.</p>  - Stream the data. Format is [Neurodata Without Borders (NWB) standard](https://nwb-overview.readthedocs.io/en/latest/)  <pre><code>path = \"allen_478498617.nwb\"\nif path not in os.listdir(\".\"):\n  r = requests.get(f\"https://osf.io/vf2nj/download\", stream=True)\n  block_size = 1024*1024\n  with open(path, 'wb') as f:\n    for data in tqdm.tqdm(r.iter_content(block_size), unit='MB', unit_scale=True,\n      total=math.ceil(int(r.headers.get('content-length', 0))//block_size)):\n      f.write(data)\n</code></pre>"},{"location":"generated/gallery/tutorial_pynapple_nemos_single_cell_full/#pynapple","title":"Pynapple","text":""},{"location":"generated/gallery/tutorial_pynapple_nemos_single_cell_full/#data-structures-and-preparation","title":"Data structures and preparation","text":"<p>Now that we've downloaded the data, let's open it with pynapple and examine its contents.</p>  - Open the NWB file with [pynapple](https://pynapple-org.github.io/pynapple/)  <pre><code>data = nap.load_file(path)\nprint(data)\n</code></pre> <p>Out:</p> <pre><code>/Users/gviejo/miniconda3/envs/fens2024/lib/python3.11/site-packages/hdmf/utils.py:668: UserWarning: Ignoring cached namespace 'hdmf-common' version 1.7.0 because version 1.8.0 is already loaded.\n  return func(args[0], **pargs)\n/Users/gviejo/miniconda3/envs/fens2024/lib/python3.11/site-packages/hdmf/utils.py:668: UserWarning: Ignoring cached namespace 'core' version 2.6.0-alpha because version 2.7.0 is already loaded.\n  return func(args[0], **pargs)\n/Users/gviejo/miniconda3/envs/fens2024/lib/python3.11/site-packages/hdmf/utils.py:668: UserWarning: Ignoring cached namespace 'hdmf-experimental' version 0.4.0 because version 0.5.0 is already loaded.\n  return func(args[0], **pargs)\nallen_478498617\n\u250d\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u252f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2511\n\u2502 Keys     \u2502 Type        \u2502\n\u251d\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u253f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2525\n\u2502 units    \u2502 TsGroup     \u2502\n\u2502 epochs   \u2502 IntervalSet \u2502\n\u2502 stimulus \u2502 Tsd         \u2502\n\u2502 response \u2502 Tsd         \u2502\n\u2515\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2537\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2519\n</code></pre> <p>The dataset contains several different pynapple objects, which we discussed yesterday. Let's see how these relate to the data we visualized above:</p> <p></p> <ul> <li><code>units</code>: dictionary of neurons, holding each neuron's spike timestamps.</li> <li><code>epochs</code>: start and end times of different intervals, defining the   experimental structure, specifying when each stimulation protocol began and   ended.</li> <li><code>stimulus</code>: injected current, in Amperes, sampled at 20k Hz.</li> <li><code>response</code>: the neuron's intracellular voltage, sampled at 20k Hz.   We will not use this info in this example</li> </ul> <p>Now let's go through the relevant variables in some more detail:</p> \" ![Annotated view of the data we will analyze.](../../assets/allen_data_annotated.gif)  - `stimulus`: Tsd containing injected current, in Amperes, sampled at 20k Hz. - `response`: Tsd containing the neuron's intracellular voltage, sampled at 20k Hz. - `units`: Tsgroup, dictionary of neurons, holding each neuron's spike timestamps. - `epochs`: IntervalSet, dictionary with start and end times of different intervals,   defining the experimental structure, specifying when each stimulation protocol began   and ended.  <p>First, let's examine the epochs:</p> <pre><code>epochs = data[\"epochs\"]\nepochs.keys()\n</code></pre> <p>Out:</p> <pre><code>dict_keys(['Long Square', 'Noise 1', 'Noise 2', 'Ramp', 'Short Square', 'Short Square - Triple', 'Square - 2s Suprathreshold', 'Test'])\n</code></pre> <p><code>epochs</code> is a dictionary with strings for keys and <code>IntervalSets</code> for values. Each key defines the stimulus protocol, with the value defining the beginning and end of that stimulation protocol.</p> \" - `Noise 1`: epochs of random noise  <pre><code>noise_interval = epochs[\"Noise 1\"]\nnoise_interval\n</code></pre> <p>Out:</p> <pre><code>            start      end\n       0  460.768  488.788\n       1  526.808  554.828\n       2  592.848  620.868\nshape: (3, 2), time unit: sec.\n</code></pre> <p>As described above, we will be examining \"Noise 1\". We can see it contains three rows, each defining a separate sweep. We'll just grab the first sweep (shown in blue in the pictures above) and ignore the other two (shown in gray).</p> \" - Let's focus on the first epoch.  <pre><code>noise_interval = noise_interval[0]\nnoise_interval\n</code></pre> <p>Out:</p> <pre><code>            start      end\n       0  460.768  488.788\nshape: (1, 2), time unit: sec.\n</code></pre> <p>Now let's examine the input current:</p> \" - `current` : Tsd (TimeSeriesData) : time index + data  <pre><code># convert current from Ampere to pico-amperes, to match the Allen Institute figures and\n# move the values to a more reasonable range.\ncurrent = data[\"stimulus\"] * 1e12\ncurrent\n</code></pre> <p>Out:</p> <pre><code>Time (s)\n-------------  --\n0.0             0\n5e-05           0\n0.0001          0\n0.00015         0\n0.0002          0\n0.00025         0\n0.0003          0\n0.00035         0\n0.0004          0\n0.00045         0\n0.0005          0\n0.00055         0\n0.0006          0\n0.00065         0\n0.0007          0\n0.00075         0\n0.0008          0\n0.00085         0\n...\n897.420099999   0\n897.420149999   0\n897.420199999   0\n897.420249999   0\n897.420299999   0\n897.420349999   0\n897.420399999   0\n897.420449999   0\n897.420499999   0\n897.420549999   0\n897.420599999   0\n897.420649999   0\n897.420699999   0\n897.420749999   0\n897.420799999   0\n897.420849999   0\n897.420899999   0\n897.420949999   0\ndtype: float64, shape: (11348420,)\n</code></pre> <p><code>current</code> is a <code>Tsd</code> (TimeSeriesData) object with 2 columns. Like all <code>Tsd</code> objects, the first column contains the time index and the second column contains the data; in this case, the current in pA.</p> <p>Currently <code>current</code> contains the entire ~900 second experiment but, as discussed above, we only want one of the \"Noise 1\" sweeps. Fortunately, <code>pynapple</code> makes it easy to grab out the relevant time points by making use of the <code>noise_interval</code> we defined above:</p> \" - `restrict` : restricts a time series object to a set of time intervals delimited by an IntervalSet object  <pre><code>current = current.restrict(noise_interval)\ncurrent\n</code></pre> <p>Out:</p> <pre><code>Time (s)\n-------------  --\n460.768         0\n460.76805       0\n460.7681        0\n460.76815       0\n460.7682        0\n460.76825       0\n460.7683        0\n460.76835       0\n460.7684        0\n460.76845       0\n460.7685        0\n460.76855       0\n460.7686        0\n460.76865       0\n460.7687        0\n460.76875       0\n460.7688        0\n460.76885       0\n...\n488.787099993   0\n488.787149993   0\n488.787199993   0\n488.787249993   0\n488.787299993   0\n488.787349993   0\n488.787399993   0\n488.787449993   0\n488.787499993   0\n488.787549993   0\n488.787599993   0\n488.787649993   0\n488.787699993   0\n488.787749993   0\n488.787799993   0\n488.787849993   0\n488.787899993   0\n488.787949993   0\ndtype: float64, shape: (560400,)\n</code></pre> <p>Notice that the timestamps have changed and our shape is much smaller.</p> <p>Finally, let's examine the spike times. These are stored in a <code>TsGroup</code>, a dictionary-like object that holds multiple <code>Ts</code> (timeseries) objects with potentially different time indices:</p> \" - `TsGroup` : a custom dictionary holding multiple `Ts` (timeseries) objects with   potentially different time indices.  <pre><code>spikes = data[\"units\"]\nspikes\n</code></pre> <p>Out:</p> <pre><code>  Index     rate  location      group\n-------  -------  ----------  -------\n      0  0.87805  v1                0\n</code></pre> <p>Typically, this is used to hold onto the spike times for a population of neurons. In this experiment, we only have recordings from a single neuron, so there's only one row.</p> <p>We can index into the <code>TsGroup</code> to see the timestamps for this neuron's spikes:</p> \" We can index into the `TsGroup` to see the timestamps for this neuron's spikes:  <pre><code>spikes[0]\n</code></pre> <p>Out:</p> <pre><code>Time (s)\n1.85082\n2.06869\n2.20292\n2.325815\n2.42342\n2.521415\n2.604795\n2.689605\n2.76657\n2.84147\n2.913\n2.978915\n3.045105\n3.106475\n3.166035\n3.21995\n3.277105\n3.328295\n...\n843.40877\n843.57167\n843.734835\n852.07777\n852.16089\n852.243975\n860.746765\n860.789795\n860.832855\n869.41565\n869.43864\n869.461695\n878.08481\n878.09765\n878.110865\n886.75375\n886.761465\n886.76995\nshape: 777\n</code></pre> <p>Similar to <code>current</code>, this object originally contains data from the entire experiment. To get only the data we need, we again use <code>restrict(noise_interval)</code>:</p> \" Let's restrict to the same epoch `noise_interval`:  <pre><code>spikes = spikes.restrict(noise_interval)\nprint(spikes)\nspikes[0]\n</code></pre> <p>Out:</p> <pre><code>  Index     rate  location      group\n-------  -------  ----------  -------\n      0  1.42755  v1                0\n\nTime (s)\n470.81754\n470.85842\n470.907235\n470.954925\n471.0074\n471.107175\n471.25083\n471.82728\n471.917655\n472.00696\n472.71008\n473.009605\n478.807455\n478.825935\n478.85967\n478.896305\n478.92566\n478.955415\n...\n479.196605\n479.24137\n479.59276\n479.669225\n479.70719\n479.815245\n479.89998\n479.94611\n479.99794\n480.196545\n480.53543\n480.67927\n480.81817\n480.90529\n480.94921\n481.002715\n481.60008\n481.67727\nshape: 40\n</code></pre> <p>Now, let's visualize the data from this trial, replicating rows 1 and 3 from the Allen Brain Atlas figure at the beginning of this notebook:</p> \" Let's visualize the data from this trial:  <pre><code>fig, ax = plt.subplots(1, 1, figsize=(8, 2))\nax.plot(current, \"grey\")\nax.plot(spikes.to_tsd([-5]), \"|\", color=\"k\", ms = 10)\nax.set_ylabel(\"Current (pA)\")\nax.set_xlabel(\"Time (s)\")\n</code></pre> <p></p> <p>Out:</p> <pre><code>Text(0.5, -6.277777777777782, 'Time (s)')\n</code></pre>"},{"location":"generated/gallery/tutorial_pynapple_nemos_single_cell_full/#basic-analyses","title":"Basic analyses","text":"<p>Before using the Generalized Linear Model, or any model, it's worth taking some time to examine our data and think about what features are interesting and worth capturing. As Edoardo explained earlier today, the GLM is a model of the neuronal firing rate. However, in our experiments, we do not observe the firing rate, only the spikes! Moreover, neural responses are typically noisy \u2014 even in this highly controlled experiment where the same current was injected over multiple trials, the spike times were slightly different from trial-to-trial. No model can perfectly predict spike times on an individual trial, so how do we tell if our model is doing a good job?</p> <p>Our objective function is the log-likelihood of the observed spikes given the predicted firing rate. That is, we're trying to find the firing rate, as a function of time, for which the observed spikes are likely. Intuitively, this makes sense: the firing rate should be high where there are many spikes, and vice versa. However, it can be difficult to figure out if your model is doing a good job by squinting at the observed spikes and the predicted firing rates plotted together. </p> <p>One common way to visualize a rough estimate of firing rate is to smooth the spikes by convolving them with a Gaussian filter.</p> <p>Info</p> <p>This is a heuristic for getting the firing rate, and shouldn't be taken as the literal truth (to see why, pass a firing rate through a Poisson process to generate spikes and then smooth the output to approximate the generating firing rate). A model should not be expected to match this approximate firing rate exactly, but visualizing the two firing rates together can help you reason about which phenomena in your data the model is able to adequately capture, and which it is missing.</p> <p>For more information, see section 1.2 of Theoretical Neuroscience, by Dayan and Abbott.</p> <p>Pynapple can easily compute this approximate firing rate, and plotting this information will help us pull out some phenomena that we think are interesting and would like a model to capture.</p> <p>First, we must convert from our spike times to binned spikes:</p> \" The Generalized Linear Model gives a predicted firing rate. First we can use pynapple to visualize this firing rate for a single trial.  - `count` : count the number of events within `bin_size`  <pre><code># bin size in seconds\nbin_size = 0.001\n# Get spikes for neuron 0\ncount = spikes[0].count(bin_size)\ncount\n</code></pre> <p>Out:</p> <pre><code>Time (s)\n----------  --\n460.7685     0\n460.7695     0\n460.7705     0\n460.7715     0\n460.7725     0\n460.7735     0\n460.7745     0\n460.7755     0\n460.7765     0\n460.7775     0\n460.7785     0\n460.7795     0\n460.7805     0\n460.7815     0\n460.7825     0\n460.7835     0\n460.7845     0\n460.7855     0\n...\n488.7705     0\n488.7715     0\n488.7725     0\n488.7735     0\n488.7745     0\n488.7755     0\n488.7765     0\n488.7775     0\n488.7785     0\n488.7795     0\n488.7805     0\n488.7815     0\n488.7825     0\n488.7835     0\n488.7845     0\n488.7855     0\n488.7865     0\n488.7875     0\ndtype: int64, shape: (28020,)\n</code></pre> <p>Now, let's convert the binned spikes into the firing rate, by smoothing them with a gaussian kernel. Pynapple again provides a convenience function for this:</p> \" Let's convert the spike counts to firing rate :  - `smooth` : convolve with a Gaussian kernel  <pre><code># the inputs to this function are the standard deviation of the gaussian in seconds and\n# the full width of the window, in standard deviations. So std=.05 and size_factor=20\n# gives a total filter size of 0.05 sec * 20 = 1 sec.\nfiring_rate = count.smooth(std=.05, size_factor=20)\n# convert from spikes per bin to spikes per second (Hz)\nfiring_rate = firing_rate / bin_size\n</code></pre> <p>Now that we've done all this preparation, let's make a plot to more easily visualize the data.</p> <pre><code># we're hiding the details of the plotting function for the purposes of this\n# tutorial, but you can find it in the associated github repo if you're\n# interested:\n# https://github.com/flatironinstitute/ccn-workshop-fens-2024/blob/main/src/workshop_utils/plotting.py\nplotting.current_injection_plot(current, spikes, firing_rate)\n</code></pre> <p></p> <p>So now that we can view the details of our experiment a little more clearly, what do we see?</p> <ul> <li> <p>We have three intervals of increasing current, and the firing rate   increases as the current does.</p> </li> <li> <p>While the neuron is receiving the input, it does not fire continuously or   at a steady rate; there appears to be some periodicity in the response. The   neuron fires for a while, stops, and then starts again. There's periodicity   in the input as well, so this pattern in the response might be reflecting   that.</p> </li> <li> <p>There's some decay in firing rate as the input remains on: there are three or   four \"bumps\" of neuronal firing in the second and third intervals and they   decrease in amplitude, with the first being the largest.</p> </li> </ul> <p>These give us some good phenomena to try and predict! But there's something that's not quite obvious from the above plot: what is the relationship between the input and the firing rate? As described in the first bullet point above, it looks to be monotonically increasing: as the current increases, so does the firing rate. But is that exactly true? What form is that relationship?</p> <p>Pynapple can compute a tuning curve to help us answer this question, by binning our spikes based on the instantaneous input current and computing the firing rate within those bins:</p>  What is the relationship between the current and the spiking activity? [`compute_1d_tuning_curves`](https://pynapple-org.github.io/pynapple/reference/process/tuning_curves/#pynapple.process.tuning_curves.compute_1d_tuning_curves) : compute the firing rate as a function of a 1-dimensional feature.  <pre><code>tuning_curve = nap.compute_1d_tuning_curves(spikes, current, nb_bins=15)\ntuning_curve\n</code></pre> 0 4.637500 0.000000 13.912500 0.000000 23.187501 0.000000 32.462501 0.000000 41.737501 0.000000 51.012501 0.000000 60.287501 3.960592 69.562502 1.755310 78.837502 4.294610 88.112502 10.993325 97.387502 12.501116 106.662502 10.275380 115.937503 33.476805 125.212503 61.585835 134.487503 24.067389 <p><code>tuning_curve</code> is a pandas DataFrame where each column is a neuron (one neuron in this case) and each row is a bin over the feature (here, the input current). We can easily plot the tuning curve of the neuron:</p> \" Let's plot the tuning curve of the neuron.  <pre><code>plotting.tuning_curve_plot(tuning_curve)\n</code></pre> <p></p> <p>Out:</p> <pre><code>&lt;Figure size 640x480 with 1 Axes&gt;\n</code></pre> <p>We can see that, while the firing rate mostly increases with the current, it's definitely not a linear relationship, and it might start decreasing as the current gets too large.</p> <p>So this gives us three interesting phenomena we'd like our model to help explain: the tuning curve between the firing rate and the current, the firing rate's periodicity, and the gradual reduction in firing rate while the current remains on.</p>"},{"location":"generated/gallery/tutorial_pynapple_nemos_single_cell_full/#nemos","title":"NeMoS","text":""},{"location":"generated/gallery/tutorial_pynapple_nemos_single_cell_full/#preparing-data","title":"Preparing data","text":"<p>Now that we understand our model, we're almost ready to put it together. Before we construct it, however, we need to get the data into the right format.</p> <p>NeMoS requires that the predictors and spike counts it operates on have the following properties:</p> <ul> <li> <p>predictors and spike counts must have the same number of time points.</p> </li> <li> <p>predictors must be two-dimensional, with shape <code>(n_time_bins, n_features)</code>.   In this example, we have a single feature (the injected current).</p> </li> <li> <p>spike counts must be one-dimensional, with shape <code>(n_time_bins, )</code>. As   discussed above, <code>n_time_bins</code> must be the same for both the predictors and   spike counts.</p> </li> <li> <p>predictors and spike counts must be   <code>jax.numpy</code>   arrays, <code>numpy</code> arrays, or <code>pynapple</code> <code>TsdFrame</code>/<code>Tsd</code>.</p> </li> </ul> <p>What is jax?</p> <p>jax is a Google-supported python library for automatic differentiation. It has all sorts of neat features, but the most relevant of which for NeMoS is its GPU-compatibility and just-in-time compilation (both of which make code faster with little overhead!), as well as the collection of optimizers present in jaxopt.</p> <p>First, we require that our predictors and our spike counts have the same number of time bins. We can achieve this by down-sampling our current to the spike counts to the proper resolution using the <code>bin_average</code> method from pynapple:</p> <p>Info</p> <p>We refer to the model inputs as both \"the predictors\" and \"the design matrix,\" a term which comes from statistics.</p>   Get data from pynapple to NeMoS-ready format:    - predictors and spikes must have same number of time points  <pre><code>binned_current = current.bin_average(bin_size)\n\nprint(f\"current shape: {binned_current.shape}\")\n# rate is in Hz, convert to KHz\nprint(f\"current sampling rate: {binned_current.rate/1000.:.02f} KHz\")\n\nprint(f\"\\ncount shape: {count.shape}\")\nprint(f\"count sampling rate: {count.rate/1000:.02f} KHz\")\n</code></pre> <p>Out:</p> <pre><code>current shape: (28020,)\ncurrent sampling rate: 1.00 KHz\n\ncount shape: (28020,)\ncount sampling rate: 1.00 KHz\n</code></pre> <p>Secondly, we have to reshape our variables so that they are the proper shape:</p> <ul> <li><code>predictors</code>: <code>(n_time_bins, n_features)</code></li> <li><code>count</code>: <code>(n_time_bins, )</code></li> </ul> <p>Because we only have a single predictor feature, we'll use <code>np.expand_dims</code> to ensure it is a 2d array.</p>    - predictors must be 2d, spikes 1d  <pre><code># make sure predictor is 2d\npredictor = np.expand_dims(binned_current, 1)\n\n# check that the dimensionality matches NeMoS expectation\nprint(f\"predictor shape: {predictor.shape}\")\nprint(f\"count shape: {count.shape}\")\n</code></pre> <p>Out:</p> <pre><code>predictor shape: (28020, 1)\ncount shape: (28020,)\n</code></pre> <p>What if I have more than one neuron?</p> <p>In this example, we're only fitting data for a single neuron, but you might wonder how the data should be shaped if you have more than one neuron \u2014 do you add an extra dimension? or concatenate neurons along one of the existing dimensions?</p> <p>In NeMoS, we fit Generalized Linear Models to a single neuron at a time. We'll discuss this more in the following tutorial, but briefly: you get the same answer whether you fit the neurons separately or simultaneously, and fitting them separately can make your life easier. We also provide a <code>PopulationGLM</code> object to fit an entirely population at once, if you prefer to do so.</p>"},{"location":"generated/gallery/tutorial_pynapple_nemos_single_cell_full/#fitting-the-model","title":"Fitting the model","text":"<p>Now we're ready to fit our model!</p> <p>First, we need to define our GLM model object. We intend for users to interact with our models like scikit-learn estimators. In a nutshell, a model instance is initialized with hyperparameters that specify optimization and model details, and then the user calls the <code>.fit()</code> function with the design matrix and the observed data to fit the model. We will walk you through the process below by example, but if you are interested in reading more details see the Getting Started with scikit-learn webpage.</p> <p>To initialize our model, we need to specify the regularizer and observation model objects, both of which should be one of our custom objects:</p> <ul> <li>Regularizer: this object specifies both the solver algorithm and the   regularization scheme. They are jointly specified because each   regularization scheme has a list of compatible solvers to choose between.   Regularization modifies the objective function to reflect your prior   beliefs about the parameters, such as sparsity. Regularization becomes more   important as the number of input features, and thus model parameters,   grows. They can be found within <code>nemos.regularizer</code>.</li> </ul> <p>Warning</p> <p>With a convex problem like the GLM, in theory it does not matter which solver algorithm you use. In practice, due to numerical issues, it generally does. Thus, it's worth trying a couple to see how their solutions compare. (Note that, since regularization modifies the objective function, different regularization schemes will always give different results.)</p> <ul> <li>Observation model: this object links the firing rate and the observed data (in this   case, spikes), describing the distribution of neural activity (and thus changing the   log-likelihood). For spiking data, we use the Poisson observation model, but nemos   provides other options for continuous data, such as calcium imaging.</li> </ul> <p>For this example, we'll use an un-regularized LBFGS solver. We'll discuss regularization in a later tutorial.</p> <p>Why LBFGS?</p> <p>LBFGS is a quasi-Netwon method, that is, it uses the first derivative (the gradient) and approximates the second derivative (the Hessian) in order to solve the problem. This means that LBFGS tends to find a solution faster and is often less sensitive to step-size. Try other solvers to see how they behave!</p>    - Define a GLM object  <pre><code>model = nmo.glm.GLM(solver_name=\"LBFGS\")\n</code></pre> <p>Now that we've initialized our model with the optimization parameters, we can fit our data! In the previous section, we prepared our model matrix (<code>predictor</code>) and target data (<code>count</code>), so to fit the model we just need to pass them to the model:</p>    - call fit and retrieve parameters  <pre><code>model.fit(predictor, count)\n</code></pre> <p>Out:</p> <pre><code>&lt;nemos.glm.GLM object at 0x1026a2190&gt;\n</code></pre> <p>Now that we've fit our data, we can retrieve the resulting parameters. Similar to scikit-learn, these are stored as the <code>coef_</code> and <code>intercept_</code> attributes:</p> <pre><code>print(f\"firing_rate(t) = exp({model.coef_} * current(t) + {model.intercept_})\")\n</code></pre> <p>Out:</p> <pre><code>firing_rate(t) = exp([0.05330383] * current(t) + [-9.761143])\n</code></pre> <p>Note that <code>model.coef_</code> has shape <code>(n_features, )</code> and <code>model.intercept_</code> has shape <code>(n_neurons, )</code> (in this case, both are 1):</p> <pre><code>print(f\"coef_ shape: {model.coef_.shape}\")\nprint(f\"intercept_ shape: {model.intercept_.shape}\")\n</code></pre> <p>Out:</p> <pre><code>coef_ shape: (1,)\nintercept_ shape: (1,)\n</code></pre> <p>It's nice to get the parameters above, but we can't tell how well our model is doing by looking at them. So how should we evaluate our model?</p> <p>First, we can use the model to predict the firing rates and compare that to the smoothed spike train. By calling <code>predict()</code> we can get the model's predicted firing rate for this data. Note that this is just the output of the model's linear and nonlinear steps, as described in Edoardo's presentation!</p>    - generate and examine model predictions.  <pre><code>predicted_fr = model.predict(predictor)\n# convert units from spikes/bin to spikes/sec\npredicted_fr = predicted_fr / bin_size\n\n# and let's smooth the firing rate the same way that we smoothed the\n# spike train\nsmooth_predicted_fr = predicted_fr.smooth(.05, size_factor=20)\n\n# and plot!\nplotting.current_injection_plot(current, spikes, firing_rate,\n                                               smooth_predicted_fr)\n</code></pre> <p></p> <p>Out:</p> <pre><code>/Users/gviejo/pynapple/pynapple/core/utils.py:196: UserWarning: Converting 'd' to numpy.array. The provided array was of type 'ArrayImpl'.\n  warnings.warn(\n</code></pre> <p>What do we see above? Note that the y-axes in the final row are different for each subplot!</p> <ul> <li> <p>Predicted firing rate increases as injected current goes up \u2014 Success! </p> </li> <li> <p>The amplitude of the predicted firing rate only matches the observed   amplitude in the third interval: it's too high in the first and too low in   the second \u2014 Failure! </p> </li> <li> <p>Our predicted firing rate has the periodicity we see in the smoothed spike   train \u2014 Success! </p> </li> <li> <p>The predicted firing rate does not decay as the input remains on: the   amplitudes are identical for each of the bumps within a given interval \u2014   Failure! </p> </li> </ul> <p>The failure described in the second point may seem particularly confusing \u2014 approximate amplitude feels like it should be very easy to capture, so what's going on?</p> <p>To get a better sense, let's look at the mean firing rate over the whole period:</p>    - what do we see?  <pre><code># compare observed mean firing rate with the model predicted one\nprint(f\"Observed mean firing rate: {np.mean(count) / bin_size} Hz\")\nprint(f\"Predicted mean firing rate: {np.mean(predicted_fr)} Hz\")\n</code></pre> <p>Out:</p> <pre><code>Observed mean firing rate: 1.4275517487508922 Hz\nPredicted mean firing rate: 1.430655598640442 Hz\n</code></pre> <p>We matched the average pretty well! So we've matched the average and the range from the third interval reasonably well, but overshot at low inputs and undershot in the middle.</p> <p>We can see this more directly by computing the tuning curve for our predicted firing rate and comparing that against our smoothed spike train from the beginning of this notebook. Pynapple can help us again with this:</p>    - examine tuning curve \u2014 what do we see?  <pre><code>tuning_curve_model = nap.compute_1d_tuning_curves_continuous(predicted_fr, current, 15)\nfig = plotting.tuning_curve_plot(tuning_curve)\nfig.axes[0].plot(tuning_curve_model, color=\"tomato\", label=\"glm\")\nfig.axes[0].legend()\n</code></pre> <p></p> <p>Out:</p> <pre><code>&lt;matplotlib.legend.Legend object at 0x329f7c4d0&gt;\n</code></pre> <p>In addition to making the mismatch at low and medium input values discussed earlier a little more obvious, this tuning curve comparison also highlights that this model thinks the firing rate will continue to grow as the injected current increases, which is not reflected in the data.</p> <p>Viewing this plot also makes it clear that the model's tuning curve is approximately exponential. We already knew that! That's what it means to be a LNP model of a single input. But it's nice to see it made explicit.</p>"},{"location":"generated/gallery/tutorial_pynapple_nemos_single_cell_full/#extending-the-model","title":"Extending the model","text":"<p>We can try extending the model in order to improve its performance. There are many ways one can do this: the iterative refinement and improvement of your model is an important part of the scientific process! In this tutorial, we'll discuss one such extension, but you're encouraged to try others.</p> <p>Our model right now assumes that the neuron's spiking behavior is only driven by the instantaneous input current. That is, we're saying that history doesn't matter. But we know that neurons integrate information over time, so why don't we add extend our model to reflect that?</p> <p>To do so, we will change our predictors, including variables that represent the history of the input current as additional columns. First, we must decide the duration of time that we think is relevant: does current passed to the cell 10 msec ago matter? what about 100 msec? 1 sec? To start, we should use our a priori knowledge about the system to determine a reasonable initial value. Later, we can examine the model parameters and do formal model comparison in order to determine how much history is necessary.</p> <p>For now, let's use a duration of 200 msec:</p>    - choose a length of time over which the neuron integrates the input current  <pre><code>current_history_duration_sec = .2\n# convert this from sec to bins\ncurrent_history_duration = int(current_history_duration_sec / bin_size)\n</code></pre> <p>To construct our new predictors, we could simply take the current and shift it incrementally. The value of predictor <code>binned_current</code> at time $t$ is the injected current at time $t$; by shifting <code>binned_current</code> backwareds by 1, we are modeling the effect of the current at time $t-1$ on the firing rate at time $t$, and so on for all shifts $i$ up to <code>current_history_duration</code>:</p> <pre><code>binned_current[1:]\nbinned_current[2:]\n# etc\n</code></pre> <p>Out:</p> <pre><code>Time (s)\n----------  --\n460.7705     0\n460.7715     0\n460.7725     0\n460.7735     0\n460.7745     0\n460.7755     0\n460.7765     0\n460.7775     0\n460.7785     0\n460.7795     0\n460.7805     0\n460.7815     0\n460.7825     0\n460.7835     0\n460.7845     0\n460.7855     0\n460.7865     0\n460.7875     0\n...\n488.7705     0\n488.7715     0\n488.7725     0\n488.7735     0\n488.7745     0\n488.7755     0\n488.7765     0\n488.7775     0\n488.7785     0\n488.7795     0\n488.7805     0\n488.7815     0\n488.7825     0\n488.7835     0\n488.7845     0\n488.7855     0\n488.7865     0\n488.7875     0\ndtype: float64, shape: (28018,)\n</code></pre> <p>In general, however, this is not a good way to extend the model in the way discussed. You will end end up with a very large number of predictive variables (one for every bin shift!), which will make the model more sensitive to noise in the data.</p> <p>A better idea is to do some dimensionality reduction on these predictors, by parametrizing them using basis functions. These will allow us to capture interesting non-linear effects with a relatively low-dimensional parametrization that preserves convexity. NeMoS has a whole library of basis objects available at <code>nmo.basis</code>, and choosing which set of basis functions and their parameters, like choosing the duration of the current history predictor, requires knowledge of your problem, but can later be examined using model comparison tools.</p> <p>For history-type inputs like we're discussing, the raised cosine log-stretched basis first described in Pillow et al., 2005 <sup>1</sup> is a good fit. This basis set has the nice property that their precision drops linearly with distance from event, which is a makes sense for many history-related inputs in neuroscience: whether an input happened 1 or 5 msec ago matters a lot, whereas whether an input happened 51 or 55 msec ago is less important.</p> <pre><code>plotting.plot_basis()\n</code></pre> <p></p> <p>NeMoS's <code>Basis</code> objects handle the construction and use of these basis functions. When we instantiate this object, the main argument we need to specify is the number of functions we want: with more basis functions, we'll be able to represent the effect of the corresponding input with the higher precision, at the cost of adding additional parameters.</p> <p>We also need to specify whether we want to use the basis in convolutional (<code>\"conv\"</code>) or evaluation (<code>\"eval\"</code>) mode. This is determined by the type of feature we wish to represent with the basis:</p> <ul> <li> <p>Evaluation mode transforms the input through the non-linear function defined by the   basis. This can be used to represent features such as spatial location and head   direction.</p> </li> <li> <p>Convolution mode applies a convolution of the input data to the bank of filters   defined by the basis, and is particularly useful when analyzing data with inherent   temporal dependencies, such as spike history or the history of input current in this   example. In convolution mode, we must additionally specify the <code>window_size</code>, the   length of the filters in bins.</p> </li> </ul>    - define a basis object  <pre><code>basis = nmo.basis.RaisedCosineBasisLog(\n    n_basis_funcs=10, mode=\"conv\", window_size=current_history_duration,\n)\n</code></pre> <p>Visualizing <code>Basis</code> objects</p> <p>NeMoS provides some convenience functions for quickly visualizing the basis, in order to create plots like the type seen above.</p> <pre><code># basis_kernels is an array of shape (current_history_duration, n_basis_funcs)\n# while time is an array of shape (current_history_duration, )\ntime, basis_kernels = basis.evaluate_on_grid(current_history_duration)\n# convert time to sec\ntime *= current_history_duration_sec\nplt.plot(time, basis_kernels)\n</code></pre> <p>With this basis in hand, we can compress our input features:</p>    - create the design matrix   - examine the features it contains  <pre><code># under the hood, this convolves the input with the filter bank visualized above\ncurrent_history = basis.compute_features(binned_current)\nprint(current_history)\n</code></pre> <p>Out:</p> <pre><code>/Users/gviejo/pynapple/pynapple/core/utils.py:196: UserWarning: Converting 'd' to numpy.array. The provided array was of type 'ArrayImpl'.\n  warnings.warn(\nTime (s)      0    1    2    3    4  ...\n----------  ---  ---  ---  ---  ---  -----\n460.7685    nan  nan  nan  nan  nan  ...\n460.7695    nan  nan  nan  nan  nan  ...\n460.7705    nan  nan  nan  nan  nan  ...\n460.7715    nan  nan  nan  nan  nan  ...\n460.7725    nan  nan  nan  nan  nan  ...\n460.7735    nan  nan  nan  nan  nan  ...\n460.7745    nan  nan  nan  nan  nan  ...\n460.7755    nan  nan  nan  nan  nan  ...\n460.7765    nan  nan  nan  nan  nan  ...\n460.7775    nan  nan  nan  nan  nan  ...\n460.7785    nan  nan  nan  nan  nan  ...\n460.7795    nan  nan  nan  nan  nan  ...\n460.7805    nan  nan  nan  nan  nan  ...\n460.7815    nan  nan  nan  nan  nan  ...\n460.7825    nan  nan  nan  nan  nan  ...\n460.7835    nan  nan  nan  nan  nan  ...\n460.7845    nan  nan  nan  nan  nan  ...\n460.7855    nan  nan  nan  nan  nan  ...\n...\n488.7705      0    0    0    0    0  ...\n488.7715      0    0    0    0    0  ...\n488.7725      0    0    0    0    0  ...\n488.7735      0    0    0    0    0  ...\n488.7745      0    0    0    0    0  ...\n488.7755      0    0    0    0    0  ...\n488.7765      0    0    0    0    0  ...\n488.7775      0    0    0    0    0  ...\n488.7785      0    0    0    0    0  ...\n488.7795      0    0    0    0    0  ...\n488.7805      0    0    0    0    0  ...\n488.7815      0    0    0    0    0  ...\n488.7825      0    0    0    0    0  ...\n488.7835      0    0    0    0    0  ...\n488.7845      0    0    0    0    0  ...\n488.7855      0    0    0    0    0  ...\n488.7865      0    0    0    0    0  ...\n488.7875      0    0    0    0    0  ...\ndtype: float32, shape: (28020, 10)\n</code></pre> <p>We can see that our design matrix is now 28020 time points by 10 features, one for each of our basis functions. If we had used the raw shifted data as the features, like we started to do above, we'd have a design matrix with 200 features, so we've ended up with more than an order of magnitude fewer features!</p> <p>Note that we have a bunch of NaNs at the beginning of each column. That's because of boundary handling: we're using the input of the past 200 msecs to predict the firing rate at time $t$, so what do we do in the first 200 msecs? The safest way is to ignore them, so that the model doesn't consider them during the fitting procedure.</p> <p>What do these features look like?</p> <pre><code># in this plot, we're normalizing the amplitudes to make the comparison easier --\n# the amplitude of these features will be fit by the model, so their un-scaled\n# amplitudes is not informative\nplotting.plot_current_history_features(binned_current, current_history, basis,\n                                                      current_history_duration_sec)\n</code></pre> <p></p> <p>On the top row, we're visualizing the basis functions, as above. On the bottom row, we're showing the input current, as a black dashed line, and corresponding features over a small window of time, just as the current is being turned on. These features are the result of a convolution between the basis function on the top row with the black dashed line shown below. As the basis functions get progressively wider and delayed from the event start, we can thus think of the features as weighted averages that get progressively later and smoother. Let's step through that a bit more slowly.</p> <p>In the leftmost plot, we can see that the first feature almost perfectly tracks the input. Looking at the basis function above, that makes sense: this function's max is at 0 and quickly decays. This feature is thus a very slightly smoothed version of the instantaneous current feature we were using before. In the middle plot, we can see that the last feature has a fairly long lag compared to the current, and is a good deal smoother. Looking at the rightmost plot, we can see that the other features vary between these two extremes, getting smoother and more delayed.</p> <p>These are the elements of our feature matrix: representations of not just the instantaneous current, but also the current history, with precision decreasing as the lag between the predictor and current increases. Let's see what this looks like when we go to fit the model!</p> <p>We'll initialize and create the GLM object in the same way as before, only changing the design matrix we pass to the model:</p>    - create and fit the GLM   - examine the parameters  <pre><code>history_model = nmo.glm.GLM(solver_name=\"LBFGS\")\nhistory_model.fit(current_history, count)\n</code></pre> <p>Out:</p> <pre><code>&lt;nemos.glm.GLM object at 0x329f0abd0&gt;\n</code></pre> <p>As before, we can examine our parameters, <code>coef_</code> and <code>intercept_</code>:</p> <pre><code>print(f\"firing_rate(t) = exp({history_model.coef_} * current(t) + {history_model.intercept_})\")\n</code></pre> <p>Out:</p> <pre><code>firing_rate(t) = exp([-0.18239757  0.19256012 -0.08882547  0.02926374 -0.00101938 -0.00541549\n  0.00264424 -0.00147817  0.00111308 -0.00063025] * current(t) + [-7.5384316])\n</code></pre> <p>Notice the shape of these parameters:</p> <pre><code>print(history_model.coef_.shape)\nprint(history_model.intercept_.shape)\n</code></pre> <p>Out:</p> <pre><code>(10,)\n(1,)\n</code></pre> <p><code>coef_</code> has 10 values now, while <code>intercept_</code> still has one \u2014 why is that? Because we now have 10 features, but still only 1 neuron whose firing rate we're predicting.</p> <p>Let's re-examine our predicted firing rate and see how the new model does:</p>    - compare the predicted firing rate to the data and the old model   - what do we see?  <pre><code># all this code is the same as above\nhistory_pred_fr = history_model.predict(current_history)\nhistory_pred_fr = history_pred_fr / bin_size\nsmooth_history_pred_fr = history_pred_fr.dropna().smooth(.05, size_factor=20)\nplotting.current_injection_plot(current, spikes, firing_rate,\n                                               # compare against the old firing rate\n                                               smooth_history_pred_fr, smooth_predicted_fr)\n</code></pre> <p></p> <p>Out:</p> <pre><code>/Users/gviejo/pynapple/pynapple/core/utils.py:196: UserWarning: Converting 'd' to numpy.array. The provided array was of type 'ArrayImpl'.\n  warnings.warn(\n</code></pre> <p>We can see that there are only some small changes here. Our new model maintains the two successes of the old one: firing rate increases with injected current and shows the observed periodicity. Our model has not improved the match between the firing rate in the first or second intervals, but it seems to do a better job of capturing the onset transience, especially in the third interval.</p> <p>We can similarly examine our mean firing rate and the tuning curves we examined before:</p>    - examine the predicted average firing rate and tuning curve   - what do we see?  <pre><code># compare observed mean firing rate with the history_model predicted one\nprint(f\"Observed mean firing rate: {np.mean(count) / bin_size} Hz\")\nprint(f\"Predicted mean firing rate (instantaneous current): {np.nanmean(predicted_fr)} Hz\")\nprint(f\"Predicted mean firing rate (current history): {np.nanmean(smooth_history_pred_fr)} Hz\")\n\ntuning_curve_history_model = nap.compute_1d_tuning_curves_continuous(smooth_history_pred_fr, current, 15)\nfig = plotting.tuning_curve_plot(tuning_curve)\nfig.axes[0].plot(tuning_curve_history_model, color=\"tomato\", label=\"glm (current history)\")\nfig.axes[0].plot(tuning_curve_model, color=\"tomato\", linestyle='--', label=\"glm (instantaneous current)\")\nfig.axes[0].legend()\n</code></pre> <p></p> <p>Out:</p> <pre><code>Observed mean firing rate: 1.4275517487508922 Hz\nPredicted mean firing rate (instantaneous current): 1.430655598640442 Hz\nPredicted mean firing rate (current history): 1.9733861848380185 Hz\n\n&lt;matplotlib.legend.Legend object at 0x354c914d0&gt;\n</code></pre> <p>This new model is actually doing a worse job matching the mean firing rate. Looking at the tuning curve, it looks like this model does predict response saturation, at about the right level, and it seems to do a better job at the lower current levels , though its maximum firing is far too low.</p> <p>Comparing the two models by examining their predictions is important, but you may also want a number with which to evaluate and compare your models' performance. As discussed earlier, the GLM optimizes log-likelihood to find the best-fitting weights, and we can calculate this number using its <code>score</code> method:</p>    - use log-likelihood to compare models  <pre><code>log_likelihood = model.score(predictor, count, score_type=\"log-likelihood\")\nprint(f\"log-likelihood (instantaneous current): {log_likelihood}\")\nlog_likelihood = history_model.score(current_history, count, score_type=\"log-likelihood\")\nprint(f\"log-likelihood (current history): {log_likelihood}\")\n</code></pre> <p>Out:</p> <pre><code>log-likelihood (instantaneous current): -0.007939920760691166\nlog-likelihood (current history): -0.008206888101994991\n</code></pre> <p>This log-likelihood is un-normalized and thus doesn't mean that much by itself, other than \"higher=better\". When comparing alternative GLMs fit on the same dataset, whether that's models using different regularizers and solvers or those using different predictors, comparing log-likelihoods is a reasonable thing to do.</p> <p>Info</p> <p>Under the hood, NeMoS is minimizing the negative log-likelihood, as is typical in many optimization contexts. <code>score</code> returns the real log-likelihood, however, and thus higher is better.</p> <p>Thus, we can see that, judging by the log-likelihood, the addition of the current history to the model does slightly improve it. However, notice that we increased our number of parameters tenfold, and only found a small improvement in performance. Increasing the number of parameters makes you more susceptible to overfitting \u2014 is this tradeoff worth it? To properly answer this question, one should split the dataset into test and train sets, training the model on one subset of the data and testing it on another to test the model's generalizability. We'll see a simple version of this in the next exercise, and a more streamlined version, using <code>scikit-learn</code>'s pipelining and cross-validation machinery, will be presented in an advanced exercise.</p>"},{"location":"generated/gallery/tutorial_pynapple_nemos_single_cell_full/#finishing-up","title":"Finishing up","text":"<p>Note that, because the log-likelihood is un-normalized, it should not be compared across datasets (because e.g., it won't account for difference in noise levels). We provide the ability to compute the pseudo-$R^2$ for this purpose:</p>    - what if you want to compare models across datasets?  <pre><code>r2 = model.score(predictor, count, score_type='pseudo-r2-Cohen')\nprint(f\"pseudo-r2 (instantaneous current): {r2}\")\nr2 = history_model.score(current_history, count, score_type='pseudo-r2-Cohen')\nprint(f\"pseudo-r2 (current history): {r2}\")\n</code></pre> <p>Out:</p> <pre><code>pseudo-r2 (instantaneous current): 0.3037663698196411\npseudo-r2 (current history): 0.28069862723350525\n</code></pre> <p>Additionally, you might be wondering how to simulate spikes \u2014 the GLM is a LNP model, but the firing rate is just the output of LN, its first two steps. The firing rate is just the mean of a Poisson process, so we can pass it to <code>jax.random.poisson</code>:</p>    - what about spiking?  <pre><code>spikes = jax.random.poisson(jax.random.PRNGKey(123), predicted_fr.values)\n</code></pre> <p>Note that this is not actually that informative and, in general, it is recommended that you focus on firing rates when interpreting your model.</p> <p>Also, while including spike history is often helpful, it can sometimes make simulations unstable: if your GLM includes auto-regressive inputs (e.g., neurons are connected to themselves or each other), simulations can sometimes can behave poorly because of runaway excitation <sup>2</sup> <sup>3</sup>.</p>"},{"location":"generated/gallery/tutorial_pynapple_nemos_single_cell_full/#further-exercises","title":"Further Exercises","text":"- what else can we do?  <p>Despite the simplicity of this dataset, there is still more that we can do here. The following sections provide some possible exercises to try yourself!</p>"},{"location":"generated/gallery/tutorial_pynapple_nemos_single_cell_full/#other-stimulation-protocols","title":"Other stimulation protocols","text":"<p>We've only fit the model to a single stimulation protocol, but our dataset contains many more! How does the model perform on \"Ramp\"? On \"Noise 2\"? Based on the example code above, write new code that fits the model on some other stimulation protocol and evaluate its performance. Which stimulation does it perform best on? Which is the worst?</p>"},{"location":"generated/gallery/tutorial_pynapple_nemos_single_cell_full/#train-and-test-sets","title":"Train and test sets","text":"<p>In this example, we've used been fitting and evaluating our model on the same data set. That's generally a bad idea! Try splitting the data in to train and test sets, fitting the model to one portion of the data and evaluating on another portion. You could split this stimulation protocol into train and test sets or use different protocols to train and test on.</p>"},{"location":"generated/gallery/tutorial_pynapple_nemos_single_cell_full/#model-extensions","title":"Model extensions","text":"<p>Even our extended model did not do a good job capturing the onset transience seen in the data, and we could probably improve the match between the amplitudes of the predicted firing rate and smoothed spike train. How would we do that?</p> <p>We could try adding the following inputs to the model, alone or together:</p> <ul> <li> <p>Tinkering with the current history: we tried adding the current history to the   model, but we only investigated one set of choices with the basis functions. What if   we tried changing the duration of time we considered   (<code>current_history_duration_sec</code>)? Different numbers of basis functions? A different   choice for the <code>Basis</code> object altogether? What effects would these have on our model?</p> </li> <li> <p>Spiking history: we know neurons have a refactory period (they are unable to spike a   second time immediately after spiking), so maybe making the model aware of whether   the neuron spiked recently could help better capture the onset transience.</p> </li> <li> <p>More complicated tuning curve: as we saw with the tuning curve plots, neither model   explored here quite accurately captures the relationship between the current and the   firing rate. Can we improve that somehow? We saw that adding the current history   changed this relationship, but we can also change it without including the history   by using a basis object in <code>\"eval\"</code> mode.</p> </li> </ul>"},{"location":"generated/gallery/tutorial_pynapple_nemos_single_cell_full/#data-citation","title":"Data citation","text":"<p>The data used in this tutorial is from the Allen Brain Map, with the following citation:</p> <p>Contributors: Agata Budzillo, Bosiljka Tasic, Brian R. Lee, Fahimeh Baftizadeh, Gabe Murphy, Hongkui Zeng, Jim Berg, Nathan Gouwens, Rachel Dalley, Staci A. Sorensen, Tim Jarsky, Uygar S\u00fcmb\u00fcl Zizhen Yao</p> <p>Dataset: Allen Institute for Brain Science (2020). Allen Cell Types Database -- Mouse Patch-seq [dataset]. Available from brain-map.org/explore/classes/multimodal-characterization.</p> <p>Primary publication: Gouwens, N.W., Sorensen, S.A., et al. (2020). Integrated morphoelectric and transcriptomic classification of cortical GABAergic cells. Cell, 183(4), 935-953.E19. https://doi.org/10.1016/j.cell.2020.09.057</p> <p>Patch-seq protocol: Lee, B. R., Budzillo, A., et al. (2021). Scaled, high fidelity electrophysiological, morphological, and transcriptomic cell characterization. eLife, 2021;10:e65482. https://doi.org/10.7554/eLife.65482</p> <p>Mouse VISp L2/3 glutamatergic neurons: Berg, J., Sorensen, S. A., Miller, J., Ting, J., et al. (2021) Human neocortical expansion involves glutamatergic neuron diversification. Nature, 598(7879):151-158. doi: 10.1038/s41586-021-03813-8</p> <p>Total running time of the script: ( 0 minutes  8.606 seconds)</p> <p> Download Python source code: tutorial_pynapple_nemos_single_cell_full.py</p> <p> Download Jupyter notebook: tutorial_pynapple_nemos_single_cell_full.ipynb</p> <p>Gallery generated by mkdocs-gallery</p> <ol> <li> <p>Pillow, J. W., Paninski, L., Uzzel, V. J., Simoncelli, E. P., &amp; J., C. E. (2005). Prediction and decoding of retinal ganglion cell responses with a probabilistic spiking model. Journal of Neuroscience, 25(47), 11003\u201311013. http://dx.doi.org/10.1523/jneurosci.3305-05.2005\u00a0\u21a9</p> </li> <li> <p>Arribas, Diego, Yuan Zhao, and Il Memming Park. \"Rescuing neural spike train models from bad MLE.\" Advances in Neural Information Processing Systems 33 (2020): 2293-2303.\u00a0\u21a9</p> </li> <li> <p>Hocker, David, and Memming Park. \"Multistep inference for generalized linear spiking models curbs runaway excitation.\" International IEEE/EMBS Conference on Neural Engineering, May 2017.\u00a0\u21a9</p> </li> </ol>"}]}